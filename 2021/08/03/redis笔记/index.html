<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>redis笔记 | YouSec</title><meta name="keywords" content="redis主从复制,redis高可用,redis集群,redis数据类型,redis编码,redis持久化"><meta name="author" content="yousec"><meta name="copyright" content="yousec"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="redis的主从复制当存在多台redis服务器的时候，会有一台主服务器master，以及若干台从服务器slaves。一般说，都是master进行写操作，slaves进行读操作。 那么，master与slaves之间是怎么进行数据同步的呢？这就是redis主从复制的由来。 原理通过数据复制，redis一个master可以挂载多个slave，每个slave下面还可以挂载次一级的slave，形成多级嵌套">
<meta property="og:type" content="article">
<meta property="og:title" content="redis笔记">
<meta property="og:url" content="http://example.com/2021/08/03/redis%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="YouSec">
<meta property="og:description" content="redis的主从复制当存在多台redis服务器的时候，会有一台主服务器master，以及若干台从服务器slaves。一般说，都是master进行写操作，slaves进行读操作。 那么，master与slaves之间是怎么进行数据同步的呢？这就是redis主从复制的由来。 原理通过数据复制，redis一个master可以挂载多个slave，每个slave下面还可以挂载次一级的slave，形成多级嵌套">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-08-03T15:08:40.000Z">
<meta property="article:modified_time" content="2021-08-03T15:10:22.273Z">
<meta property="article:author" content="yousec">
<meta property="article:tag" content="redis主从复制">
<meta property="article:tag" content="redis高可用">
<meta property="article:tag" content="redis集群">
<meta property="article:tag" content="redis数据类型">
<meta property="article:tag" content="redis编码">
<meta property="article:tag" content="redis持久化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/08/03/redis%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-03 23:10:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="YouSec" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-fw fa fa-book"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YouSec</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-fw fa fa-book"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-08-03T15:08:40.000Z" title="Created 2021-08-03 23:08:40">2021-08-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-08-03T15:10:22.273Z" title="Updated 2021-08-03 23:10:22">2021-08-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/redis/">redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h1><p>当存在多台redis服务器的时候，会有一台主服务器master，以及若干台从服务器slaves。一般说，都是master进行写操作，slaves进行读操作。</p>
<p>那么，master与slaves之间是怎么进行数据同步的呢？这就是redis主从复制的由来。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过数据复制，redis一个master可以挂载多个slave，每个slave下面还可以挂载次一级的slave，形成多级嵌套结构。<strong>所有的写操作都在master进行，master执行完成后，会将写指令分发给挂在自己下面的slave，slave会进一步分发写指令给自己次一级的slave。</strong></p>
<p>因此多节点保存数据的方式，在任何一个节点异常都不会导致数据的丢失，同时N个slave节点可以提升redis的读能力N倍。这样一个master写slave读的结构能大大提高redis的读写能力。</p>
<p>redis存在一个<strong>复制积压缓冲</strong>，当master在分发写指令给slave时，同时将写指令复制到积压缓冲去，这样做是防止slave在短时间断开重连时，只要slave的复制位置点仍在积压缓冲中就可以继续在复制位置点之后继续复制，大大提升了复制效率。因此，redis复制分为<strong>全量复制</strong>和<strong>增量复制</strong>。</p>
<p>每次复制的时候会有一个复制id，master与slave之间通过复制id进行匹配，防止slave挂到错误的master。</p>
<h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>在redis2.8之前，只支持全量复制。全量复制时，master会将内存数据通过bgsave存入rdb中，同时会构建内存快照期间的写指令，存放到<strong>复制缓冲</strong>中，当rdb构建完成后，将rdb和复制缓冲中的数据全部发送给slave，slave会完全的重新创建一份数据。</p>
<p>这种复制需要的数据量大，因此对master性能损耗大，耗时长在传递rdb时会占用大量宽带，进而对整个系统性能和资源访问都产生较大的影响。</p>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>增量复制是master只发送上次复制位置之后的写指令，不需要构建rdb，传输的内容少，因此不管是对master还是slave负荷都很小，占用的宽带也小，对系统影响几乎可以忽略。</p>
<ul>
<li>redis2.8-4.0</li>
</ul>
<p>在redis2.8之后，redis引入了psync，增加了一个<strong>复制积压缓冲</strong>，在将写指令发送给slave时，同时写在复制积压缓存中去。</p>
<p>例子：若slave在短时断开重连后，会上报master runid以及复制偏移量，master会检测runid与自己的runid是否一致并且偏移量是否在master的复制积压缓冲中，则master进行增量同步。但是若在重启时丢失了slave或master在切换之后runid会发生变化，这时仍然会进行全量复制。</p>
<ul>
<li>redis4.0</li>
</ul>
<p>针对以前的psync问题，redis引入了psync2。主从复制抛弃了runid来复制，而使用replid(复制id)作为复制判断依据。同时在构建rdb时会将replid当做辅助信息存入rdb中。重启slave时只需要加载rdb即可得到master的replid。</p>
<p>同时，每个redis处理拥有replid之外，还有个replid2。redis启动时，会创建一个长度为40的随机字符串，作为replid的初始值，在建立主从链接后，会用master的replid替换自己的replid，同时replid2会存储上次master的replid。这样在切换master时，若master与slave的replid不同，但只要slave的replid与master的replid2相同，同时复制偏移量仍然在复制积压缓冲中，就可以增量复制。</p>
<h2 id="redis复制流程"><a href="#redis复制流程" class="headerlink" title="redis复制流程"></a>redis复制流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[从库链接主库] --&gt; B[上报信息及探测]--&gt;C[ping]--&gt;D[auth]</span><br><span class="line">D[auth]--&gt;E[replconf 上报ip/port]--&gt;F[replconf 校验版本]--&gt;G[psync 准备同步]--&gt;H&#123;增量同步?&#125;</span><br><span class="line">H--&gt; | Y | H1[主库发送复制缓冲] --&gt; ret[从库接受指令并执行]</span><br><span class="line">H--&gt; | N | H2[主库发送rdb+复制缓冲]--&gt;H3[从库接受rdb文件]--&gt;H4[从库清空已有数据]--&gt;H5[从库加载rdb文件]--&gt;H6[从库重建client修正复制状态]--&gt;H1</span><br></pre></td></tr></table></figure>



<ol>
<li>slave与master建立链接,先发送ping指令,若正常则返回pong,说明master可用.若redis设置了密码,则进行密码校验.</li>
<li>slave继续通过replconfpsync2进行复制版本校验;之后从库将自己的replid、复制偏移发送给master，正式开始准备数据同步。</li>
<li>master收到psync指令后判断是否进行增量复制。</li>
<li>若slave的replid与master的replid或replid2相等，且复制偏移量仍在复制积压偏移中，则进行增量同步。master会发送continue响应，并返回master的replid。slave会将master的replid替换为自己的replid，并将之前的replid设置为replid2。之后master继续发送指令给slave完成数据同步。</li>
<li>对于全量复制，master会返回fullresync响应，附带replid以及复制偏移，之后master构建rdb，并将rdb与复制缓冲发送给slave。</li>
<li>全量复制的slave首先会清理嵌套复制，并关闭其所有子slave链接，清理自己的复制积压缓冲。之后slave会构建临时rdb文件，并从master连接中读取rdb的实际数据并写入自己rdb中，在接受完毕数据之后则将临时rdb文件改名为rdb的真正名字。接下来slave会清空老数据(即删除本地DB中的所有数据)，并暂时停止接收数据，全力加载rdb中的数据，将其写到内存中去。当rdb加载完毕之后，slave会重新利用连接的socket与master建立client，并在此注册读事件，就可以开始接收master的写指令了。此时，slave 还会将 master 的 replid 和复制偏移设为自己的复制 id 和复制偏移 offset，并将自己的 replid2 清空，因为，slave 的所有嵌套 子slave 接下来也需要进行全量复制。最后，slave 就会打开 aof 文件，在接受 master 的写指令后，执行完毕并写入到自己的 aof 中。</li>
</ol>
<h2 id="读写分离以及存在的问题"><a href="#读写分离以及存在的问题" class="headerlink" title="读写分离以及存在的问题"></a>读写分离以及存在的问题</h2><p>在主从复制上实现的读写分离，可以实现redis的读负载均衡：由主节点提供写服务，由一个或多个从节点提供读服务（多个从节点可以提高数据冗余程度以及最大化读负载能力），在读负载较大的场景下可以大大提高redis的并发量。但在使用redis读写分离时也需要注意以下问题：</p>
<h3 id="延迟与不一致"><a href="#延迟与不一致" class="headerlink" title="延迟与不一致"></a>延迟与不一致</h3><p>由于主从复制命令是异步传播的，那么一定会出现延迟和数据不一致情况。</p>
<p>若应用对延迟、不一致接受程度较低，可优化的方法：</p>
<ul>
<li>优化主从节点之间的网络环境（如同机房部署）；</li>
<li>监控主从节点之间的延迟（通过offset），若从节点延迟过大，则不再通过该节点读取数据；</li>
<li>使用集群，同时扩展读负载和写负载等。</li>
</ul>
<p>在命令传播阶段以外可能数据不一致情况更加严重，如连接在数据同步阶段、从节点失去与主节点的连接时等等。从节点的<code>slave-server-stale-data</code>便与此相关（其控制从节点的表现）：若为<code>yes</code>（默认），则从节点仍能响应客户端的命令；若为<code>no</code>，则只响应客户端的info、slaveof命令。若对数据一致性要求较高，则设置为<code>no</code>。</p>
<h3 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h3><p>在单机版的redis中存在两种删除策略：</p>
<ul>
<li>惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断其是否过期，如果过期则删除。</li>
<li>定期删除：服务器会定期删除过期数据，但是考虑到内存和CPU的折中（频繁的释放内存会对内存和CPU不友好），该删除的频率和执行时间都受到了限制。</li>
</ul>
<p>在主从复制场景下，为了数据一致性，从节点不会主动删除数据，都是主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除都不能保证及时的对从节点过期删除，因此客户端读取数据时很容易读取到过期的数据。</p>
<p>在redis3.2中，从节点读取数据时增加了对数据是否过期的判断：若该数据已过期则不返回给客户端。</p>
<h3 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h3><p>在没有使用哨兵的读写分离情况下，读写连接不同的redis节点。当主节点或从节点出现问题而发生故障时，需要及时修改应用程序读写redis的连接，连接的切换可手动执行，也可写监控程序进行切换。但前者响应慢、容易出错，后者实现复杂、成本并不低。</p>
<p>因此建议使用哨兵，使主从节点切换尽量自动化，并减少对应用程序的侵入。</p>
<h2 id="复制超时"><a href="#复制超时" class="headerlink" title="复制超时"></a>复制超时</h2><h3 id="超时判断意义"><a href="#超时判断意义" class="headerlink" title="超时判断意义"></a>超时判断意义</h3><p>在主从复制的连接时和连接后，主从节点都有判断连接是否超时，其意义在于：</p>
<ul>
<li>主节点判断超时：若超时，主节点会释放相应的各种资源；主节点也能判断当前有效从节点个数，有助于保证数据安全。</li>
<li>从节点判断超时：若超时，从节点可以及时的与主节点重新建立连接，避免与主节点数据长期不一致。</li>
</ul>
<h3 id="判断机制"><a href="#判断机制" class="headerlink" title="判断机制"></a>判断机制</h3><p>主从复制超时判断的核心在于<code>repl-timeout</code>参数，该参数规定了超时时间的阈值(默认60s)，对于主节点和从节点同时有效，其超时触发条件：</p>
<ul>
<li>主节点：每秒一次调用复制定时函数<code>replicationCron()</code>，在其中判断当前时间距离上次收到各个节点REPLCONF ACK的时间，是否超过了repl-timeout值，若超过了则释放相关从节点连接。</li>
<li>从节点：从节点判断同样是在复制定时函数中判断，其如下：<ul>
<li>建立连接阶段：若距离上次收到主节点信息时间已经超过repl-timeout，则释放连接；</li>
<li>数据同步阶段：收到主节点的RDB文件超时，则停止数据同步并释放连接；</li>
<li>命令传播阶段：距离上次收到主节点的PING命令或数据时间超过repl-timeout则释放连接。</li>
</ul>
</li>
</ul>
<p>注意：在进行慢查询时可能会导致的阻塞：在从节点或主节点进行了一些慢查询，导致服务阻塞，阻塞期间无法响应复制连接中对方节点的请求，可能会导致复制超时。</p>
<h2 id="复制缓冲区溢出"><a href="#复制缓冲区溢出" class="headerlink" title="复制缓冲区溢出"></a>复制缓冲区溢出</h2><p>除了复制超时会导致复制中断外，复制缓冲区溢出同样会导致复制中断。</p>
<p>在全量复制阶段，主节点会将执行的写命令放到复制缓冲区中，该缓冲区存放的数据包括了以下几个时间段内主节点执行的写命令：bgsave生成RDB文件、RDB文件由主节点发往从节点、从节点清空老数据并载入RDB文件中的数据。当主节点数据量较大，或者主从节点之间网络延迟较大时，可能导致该缓冲区的大小超过了限制，此时主节点会断开与从节点之间的连接；这种情况可能引起全量复制-&gt;复制缓冲区溢出导致连接中断-&gt;重连-&gt;全量复制-&gt;复制缓冲区溢出导致连接中断……的循环。</p>
<p>复制缓冲区的大小由client-output-buffer-limit slave {hard limit} {soft limit} {soft seconds}配置，默认值为client-output-buffer-limit slave 256MB 64MB 60，其含义是：如果buffer大于256MB，或者连续60s大于64MB，则主节点会断开与该从节点的连接。该参数是可以通过config set命令动态配置的（即不重启Redis也可以生效）。</p>
<p><strong>注意：复制缓冲区是客户端输出缓冲区的一种，主节点会为每个从节点分配一个复制缓冲区；而复制积压缓冲区主节点只有一个，无论它有多少个从节点。</strong></p>
<h1 id="redis的五种对象类型"><a href="#redis的五种对象类型" class="headerlink" title="redis的五种对象类型"></a>redis的五种对象类型</h1><p>redis有五种对象类型，每种结构至少有两种编码方式。这样做的好处是：一方面接口与实现分离，当需要增加或改变内部编码时用户不会收到影响；另一方面可以根据不同场景切换内部编码，提高效率。</p>
<p><strong>注意：redis内部编码转换只有在写入时完成，且转换过程不可逆，只能从小内存向大内存编码转换。</strong></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>字符串是redis最基础的编码，因为<strong>所有的键</strong>都是字符串类型，且字符串之外的其他集中复杂类型的元素也是字符串。</p>
<p><strong>字符串长度不能超过512M。</strong></p>
<h3 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h3><p>redis字符串内部编码根据大小不同有三种编码方式：</p>
<ul>
<li><code>int</code>：8字节的长整型。字符串值是整型时，这个值用long整型表示。</li>
<li><code>embstr</code>：&lt;=<code>39字节</code>的字符串。embstr与raw都是用SDS与redisObject保存数据。区别在于embstr只分配一次内存空间（因此RedisObject和sds是连续的），而raw需要分配两次内存空间（分别为RedisObject与sds分配）。好处：embstr分配和销毁时都只创建、销毁一次空间，并且对象数据连在一起方便查找。坏处：当字符串增加长度需要重新分配内存时，整个RedisObject和sds都需要重新分配空间。<strong>因此redis中的embstr实现为只读。</strong></li>
<li><code>raw</code>：&gt;39字节的字符串。</li>
</ul>
<p>可以通过以下命令查看编码类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; object encoding key</span><br></pre></td></tr></table></figure>

<p>embstr与raw为什么区分是39字节呢？</p>
<p><code>RedisObject</code>的长度是16字节，<code>sds</code>长度是9+<code>字符串长度</code>，jemalloc正好可以分配64字节内存单元，所以：16 + 9 + 39 = 64 字节。</p>
<h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p><em>当int数据不再是整数，或大小超过了long的范围时，自动转化为raw。</em></p>
<p>而对于<code>embstr</code>，由于其实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了39个字节。</p>
<p>所以当我们存储的字符串需要进行转换时可以直接指定字符串为raw减少一次字符串转换。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="概括-1"><a href="#概括-1" class="headerlink" title="概括"></a>概括</h3><p>列表(list)用来存储多个有序字符串，每个字符串称为元素。一个list可以存储<code>2^23-1</code>个元素。</p>
<p>redis中list支持<strong>两端插入和弹出</strong>，可以获得<strong>指定位置/范围</strong>的元素，可以充当<em>数组</em>、<em>队列</em>、<em>栈</em>等。</p>
<h3 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h3><p>list的内部编码可以是*压缩列表(ziplist)<em>、</em>双端链表(linkedlist)*。</p>
<p><strong>双端</strong>链表：由一个<code>list</code>和多个<code>listNode</code>组成。其保存了<em>表头表尾</em>指针，并且每个节点都有指<em>向前</em>一指针和<em>后</em>一指针，链表还保存了列表的<em>长度</em>，还有标识保存的<em>值的类型</em>字段。而链表中每个节点指向的是type为<strong>字符串的RedisObject</strong>。</p>
<p><strong>压缩</strong>列表：压缩列表是为了节约空间而开发的，由一系列特殊编码的<strong>连续内存块</strong>组成的顺序数据类型结构。其虽然空间节约，但是在操作<em>增删修改</em>时复杂度过高，所以只有在<em>节点数量较少的情况下</em>使用。</p>
<h3 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h3><p>只有同时满足下面<code>两个</code>条件时，才会使<code>用压缩</code>列表：列表中<code>元素数量小于512</code>个；列表中<code>所有字符串对象都不足64字节</code>。如果有一个条件不满足，则使用双端列表；且编码只可能由压缩列表转化为双端链表，反方向则不可能。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="概括-2"><a href="#概括-2" class="headerlink" title="概括"></a>概括</h3><p>哈希不光是redis对外提供的数据类型的一种，也是redis作为Key-Value数据库使用的数据结构。</p>
<p>在这里用<em>内层哈希</em>代表redis对外提供的一种数据类型，<em>外层哈希</em>代表redis作为K-V数据库所使用的数据结构。</p>
<h3 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h3><p>*内层的哈希(redis对外提供的五种数据结构之一)使用的内部编码为压缩列表(ziplist)和哈希表(hashtable)<em>。</em>外层的哈希（redis使用的key-value数据库使用的数据结构）只使用了哈希表(hashtable)*。</p>
<p><code>hashtable</code>：一个hashtable由一个<code>dick</code>结构、两个<code>dicktht</code>结构、一个<code>dickEntry</code>指针数组（<code>bucket</code>）和多个<code>dickEntry</code>结构组成。</p>
<img src="/2021/08/03/redis%E7%AC%94%E8%AE%B0/hashtable.png" class="" title="image-20210719223407310">

<p>从底层向上依次介绍数据结构（x64）：</p>
<ul>
<li><strong>dictEntry</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> dictEntry&#123;</span><br><span class="line">    void *key;				<span class="comment">// 键值对中的键	8byte</span></span><br><span class="line">    union&#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;						<span class="comment">//  键值对中的值，有三种类型，使用union实现	8byte</span></span><br><span class="line">    <span class="keyword">struct</span> dictEntry *next;		<span class="comment">// 指向下一个dickEntry，用于解决哈希冲突		8byte</span></span><br><span class="line">&#125;dictEntry;					<span class="comment">// 一共24byte</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>bucket</strong></li>
</ul>
<p><code>bucket</code>是一个<code>数组</code>，原始是一个指向<code>dickEntry</code>的指针，其大小为<code>len</code>，len满足<code>dictEntry&lt;len&lt;=2^n</code>条件取n最小值另len=2^n。例如：有1000个dickEntry，则大小len为1024。</p>
<ul>
<li><strong>dictht</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> dictht&#123;</span><br><span class="line">    dictEntry **table;				<span class="comment">// 指向dictEntry的指针</span></span><br><span class="line">    unsigned long size;				<span class="comment">// 哈希表的大小，即bucket的大小</span></span><br><span class="line">    unsigned long sizemask;			<span class="comment">// 大小为size-1，决定健在table中存储的位置</span></span><br><span class="line">    unsigned long used;				<span class="comment">// 已使用的dictEntry数量</span></span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>dict</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> dict&#123;</span><br><span class="line">    dictType *<span class="keyword">type</span>;		<span class="comment">// 与privdata一起来适应不同的键值对类型，创建多态字典</span></span><br><span class="line">    void *privdata;</span><br><span class="line">    <span class="comment">// ht与trehashindx用于rehash，即当hash需要扩展和缩容时使用。</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> trehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p><code>ht</code>是一个包含<code>两个项的数组</code>，每项都指向一个<code>dictht</code>结构，这也是Redis的哈希会有1个dict、2个dictht结构的原因。<strong>通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用</strong>。dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]，并清空ht[1]。</p>
<h3 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h3><p>在hash中只有满足：<strong>哈希元素数量小于512个</strong> &amp;&amp;<strong>所有键值对的键和值都小于64byte</strong>时才可以用ziplist。否则只能使用hashtable编码。并且编码<em>只能由ziplist转换为hashtable</em>。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>集合（set）与列表类似，都是用来保存多个字符串，但是其内部的元素是<strong>无序</strong>的，并且其元素<strong>不存在重复</strong>现象。</p>
<p>一个集合可以拥有<code>2^32-1</code>个元素，并且redis还支持求<strong>交集、并集、差集</strong>。</p>
<h3 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h3><p>set内部编码为<em>整数集合或哈希表</em>。</p>
<p>set在使用<code>hashtable</code>时值会被全部置为<code>NULL</code>。</p>
<p>整数集合（intset）结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> intset&#123;</span><br><span class="line">    uint32_t encoding;			<span class="comment">// 存储类型</span></span><br><span class="line">    uint32_t length;			<span class="comment">// 元素个数</span></span><br><span class="line">    int8_t contents[];			  <span class="comment">// 存储内存</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>整数集合适用于集合所有元素都是整数且集合元素数量较小的时候，与哈希表相比，整数集合的优势在于集中存储，节省空间。</p>
<h3 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h3><p>使用intset条件：<strong>元素个数小于512</strong> &amp;&amp; <strong>所有元素类型都是整数</strong>。</p>
<p>且编码只能由<code>intset</code>转换为<code>hashtable</code>。</p>
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="概括-3"><a href="#概括-3" class="headerlink" title="概括"></a>概括</h3><p>与集合唯一不同的就是zset中的<strong>元素是有序</strong>的，其值也不能重复。zset其为每个元素配一个<code>score</code>作为排序依据。</p>
<h3 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h3><p><code>zset</code>内部编码使用<code>ziplist</code>或<strong>跳跃表</strong>（<code>skiplist</code>）。</p>
<p>skiplist是一种有序的数据结构，通过在每个节点维持多个指向其他节点的指针，从而达到快速访问的目的。除了跳跃表，实现有序数据结构的另一种典型实现是平衡树；大多数情况下，跳跃表的效率可以和平衡树媲美，且<strong>跳跃表实现比平衡树简单很多多多多</strong>，因此redis中选用跳跃表代替平衡树。跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。Redis的跳跃表实现由<code>zskiplist</code>和<code>zskiplistNode</code>两个结构组成：前者用于保存<em>跳跃表信息（如头结点、尾节点、长度等）</em>，后者用于表示<em>跳跃表节点</em>。</p>
<h3 id="编码转换-4"><a href="#编码转换-4" class="headerlink" title="编码转换"></a>编码转换</h3><p>使用ziplist条件：<strong>zset中元素小于128个</strong> &amp;&amp; <strong>zset中的元素长度都小于64byte</strong>。</p>
<p>编码只能由<code>ziplist</code>转换为<code>skiplist</code>。</p>
<h1 id="redis内存应用"><a href="#redis内存应用" class="headerlink" title="redis内存应用"></a>redis内存应用</h1><h2 id="估算redis内存使用量"><a href="#估算redis内存使用量" class="headerlink" title="估算redis内存使用量"></a>估算redis内存使用量</h2><p>需要了解redis内部编码以及常用的数据结构。</p>
<p>Redis是<code>Key-Value</code>数据库，因此对每个键值对都会有一个<code>dictEntry</code>，里面存储了指<em>向Key和Value的指针</em>；<em>next指向下一个dictEntry</em>，与本Key-Value无关。其中<strong>key指向sds存储键</strong>，<strong>value指向redisObject存储值</strong>。</p>
<img src="/2021/08/03/redis%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.png" class="" title="image-20210719220214746">

<h3 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h3><p>Redis对象有5种类型；无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储。</p>
<p>redisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> redisObject &#123;</span><br><span class="line">　　unsigned <span class="keyword">type</span>:<span class="number">4</span>;			<span class="comment">// 对象类型</span></span><br><span class="line">　　unsigned encoding:<span class="number">4</span>;		<span class="comment">// 内部编码</span></span><br><span class="line">　　unsigned lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">　　<span class="keyword">int</span> refcount;			<span class="comment">// 对象被引用次数</span></span><br><span class="line">　　void *ptr;			<span class="comment">// 指向具体的数据</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>在64位系统中，一个redisObject对象大小为16byte：<code>4bit + 4bit + 24bit + 4byte + 8byte = 16byte</code>。</p>
<h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>Redis没有直接使用C字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sdshdr &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">len</span>;		<span class="comment">// buf已使用长度</span></span><br><span class="line">    <span class="keyword">int</span> free;		<span class="comment">// buf未使用长度</span></span><br><span class="line">    char buf[];		<span class="comment">// 	字节数组，用来存储字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>buf数组的长度=free+len+1（其中1表示字符串结尾的空字符）；所以，一个SDS结构占据的空间为：free所占长度+len所占长度+ buf数组的长度=4+4+free+len+1=free+len+9。</p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>以最简单的字符串类型进行说明：</p>
<p>假设有90000个键值对，key大小为7byte，每个value大小也为7byte，key与value都不是整数，那么这90000个k-v所占用的内存空间大小是多少？</p>
<p>可以确定其编码方式为embstr，小于39byte。</p>
<p>每个dictEntry占据的空间：</p>
<ol>
<li>一个dictEntry占用24字节，jemalloc会分配32byte；</li>
<li>一个key7字节，SDS（key）需要7+9=16byte，jemalloc会分配16byte；</li>
<li>一个RedisObject，16字节，jemalloc会分配16byte；</li>
<li>一个value7字节，SDS（value）需要7+9=16byte，jemalloc会分配16byte</li>
</ol>
<p>综上：一个dictEntry需要<code>32 + 16 + 16 +16 = 80byte</code>。</p>
<p>bucket大小：小于90000的2^n最小值，为131072，每个元素为8byte（指针大小为8byte），一共需要：</p>
<p><code>90000*80 + 131072*8 = 8248576</code>。</p>
<p>作为对比将key和value的长度由7字节增加到8字节，则对应的SDS变为17个字节，jemalloc会分配32个字节，因此每个dictEntry占用的字节数也由80字节变为112字节。此时估算这90000个键值对占据内存大小为：<code>90000*112 + 131072*8 = 11128576</code>。</p>
<h2 id="优化内存占用"><a href="#优化内存占用" class="headerlink" title="优化内存占用"></a>优化内存占用</h2><p>（1）<strong>利用jemalloc特性进行优化</strong></p>
<p>上一小节所讲述的90000个键值便是一个例子。由于jemalloc分配内存时数值是不连续的，因此key/value字符串变化一个字节，可能会引起占用内存很大的变动；在设计时可以利用这一点。</p>
<p>例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。</p>
<p>（2）使<strong>用整型/长整型</strong></p>
<p>如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。因此在可以使用长整型/整型代替字符串的场景下，尽量使用长整型/整型。</p>
<p>（3）<strong>共享对象</strong></p>
<p>利用共享对象，可以减少对象的创建（同时减少了redisObject的创建），节省内存空间。目前redis中的共享对象只包括10000个整数（0-9999）；可以通过调整REDIS_SHARED_INTEGERS参数提高共享对象的个数；例如将REDIS_SHARED_INTEGERS调整到20000，则0-19999之间的对象都可以共享。</p>
<p>考虑这样一种场景：论坛网站在redis中存储了每个帖子的浏览数，而这些浏览数绝大多数分布在0-20000之间，这时候通过适当增大REDIS_SHARED_INTEGERS参数，便可以利用共享对象节省内存空间。</p>
<p>（4）<strong>避免过度设计</strong></p>
<p>然而需要注意的是，不论是哪种优化场景，都要考虑内存空间与设计复杂度的权衡；而设计复杂度会影响到代码的复杂度、可维护性。</p>
<p>如果数据量较小，那么为了节省内存而使得代码的开发、维护变得更加困难并不划算；还是以前面讲到的90000个键值对为例，实际上节省的内存空间只有几MB。但是如果数据量有几千万甚至上亿，考虑内存的优化就比较必要了。</p>
<h2 id="关注内存碎片率"><a href="#关注内存碎片率" class="headerlink" title="关注内存碎片率"></a>关注内存碎片率</h2><p>内存碎片率是一个重要的参数，对redis 内存的优化有重要意义。</p>
<p>如果<em>内存碎片率过高（jemalloc在1.03左右比较正常）</em>，说明内存碎片多，内存浪费严重；这时便可以**考虑重启redis服务(redis安全重启)**，在内存中对数据进行重排，减少内存碎片。</p>
<p>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。</p>
<p>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。</p>
<h1 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h1><p>在Redis中，实现高可用的技术主要包括持久化、复制、哨兵和集群，下面分别说明它们的作用，以及解决了什么样的问题。</p>
<p>持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。</p>
<p>复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</p>
<p>哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。</p>
<p>集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。</p>
<h1 id="redis-持久化"><a href="#redis-持久化" class="headerlink" title="redis 持久化"></a>redis 持久化</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Redis持久化分为RDB持久化和AOF持久化：前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘（类似于MySQL的binlog）；由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。</p>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当Redis重新启动时，可以读取快照文件恢复数据。</p>
<h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ul>
<li>手动触发</li>
</ul>
<p>save命令和bgsave命令都可以生成RDB文件。</p>
<p>save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。</p>
<p>bgsave命令会创建一个子进程，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求。</p>
<p>bgsave命令执行过程中，只有fork子进程时会阻塞服务器，而对于save命令，整个过程都会阻塞服务器，因此save已基本被废弃，线上环境要杜绝save的使用；后文中也将只介绍bgsave命令。此外，在自动触发RDB持久化时，Redis也会选择bgsave而不是save来进行持久化；下面介绍自动触发RDB持久化的条件。</p>
<ul>
<li>自动触发</li>
</ul>
<p>save m n</p>
<p>自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。</p>
<p>save 900 1的含义是：当时间到900秒时，如果redis数据发生了至少1次变化，则执行bgsave；save 300 10和save 60 10000同理。当三个save条件满足任意一个时，都会引起bgsave的调用。</p>
<p>Redis的save m n，是通过serverCron函数、dirty计数器、和lastsave时间戳来实现的。</p>
<p>serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足，如果满足就执行bgsave。</p>
<p>dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；而当save/bgsave执行完成后，会将dirty重新置为0。</p>
<p>save m n的原理如下：每隔100ms，执行serverCron函数；在serverCron函数中，遍历save m n配置的保存条件，只要有一个条件满足，就进行bgsave。对于每一个save m n条件，只有下面两条同时满足时才算满足：</p>
<p>（1）当前时间 - lastsave &gt; m</p>
<p>（2）dirty &gt;= n</p>
<ul>
<li>其他触发时机</li>
</ul>
<p>在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点；</p>
<p>执行shutdown命令时，自动执行rdb持久化。</p>
<h3 id="RDB常用设置"><a href="#RDB常用设置" class="headerlink" title="RDB常用设置"></a>RDB常用设置</h3><p>save m n：bgsave自动触发的条件；如果没有save m n配置，相当于自动的RDB持久化关闭，不过此时仍可以通过其他方式触发</p>
<p>stop-writes-on-bgsave-error yes：当bgsave出现错误时，Redis是否停止执行写命令；设置为yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；设置为no，则Redis无视bgsave的错误继续执行写命令，当对Redis服务器的系统(尤其是硬盘)使用了监控时，该选项考虑设置为no</p>
<p>rdbcompression yes：是否开启RDB文件压缩</p>
<p>rdbchecksum yes：是否开启RDB文件的校验，在写入文件和读取文件时都起作用；关闭checksum在写入文件和启动文件时大约能带来10%的性能提升，但是数据损坏时无法发现</p>
<p>dbfilename dump.rdb：RDB文件名</p>
<p>dir ./：RDB文件和AOF文件所在目录</p>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><h3 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h3><p>Redis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：</p>
<p>appendonly yes</p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>由于需要记录Redis的每条写命令，因此AOF不需要触发，下面介绍AOF的执行流程。</p>
<p>AOF的执行流程包括：</p>
<ul>
<li><strong>命令追加</strong>(append)：将Redis的写命令追加到缓冲区aof_buf；</li>
<li><strong>文件写入</strong>(write)和<strong>文件同步</strong>(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘；</li>
<li><strong>文件重写</strong>(rewrite)：定期重写AOF文件，达到压缩的目的</li>
</ul>
<h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>Redis先将写命令追加到缓冲区，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。</p>
<h4 id="文件：写入write与同步sync函数"><a href="#文件：写入write与同步sync函数" class="headerlink" title="文件：写入write与同步sync函数"></a>文件：写入write与同步sync函数</h4><p>为了提高文件写入效率，在现代操作系统中，当用户调用write函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此<code>系统</code>同时提供了<code>fsync</code>、<code>fdatasync</code>等同步函数，可以<em>强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性</em>。</p>
<p>AOF<em>缓存区的同步文件</em>策略由参数<code>appendfsync</code>控制，各个值的含义如下：</p>
<ul>
<li><p><code>always</code>：命令写入aof_buf后立即调用系统fsync操作同步到AOF文件，fsync完成后线程返回。这种情况下，每次有写命令都要同步到AOF文件，硬盘IO成为性能瓶颈，Redis只能支持大约几百TPS写入，严重降低了Redis的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低SSD的寿命。</p>
</li>
<li><p><code>no</code>：命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步；同步由操作系统负责，通常同步周期为30秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。</p>
</li>
<li><p><code>everysec</code>：命令写入aof_buf后调用系统write操作，write完成后线程返回；fsync同步文件操作由专门的线程每秒调用一次。<strong>everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置，也是我们推荐的配置</strong>。</p>
</li>
</ul>
<h4 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h4><p>文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，AOF重写是<strong>把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作!</strong></p>
<ul>
<li><p>文件重写之所以能够压缩AOF文件，原因在于：</p>
</li>
<li><p><em>过期的数据不再写入文件</em></p>
</li>
<li><p><em>无效的命令不再写入文件</em>：如有些数据被重复设值(set mykey v1, set mykey v2)、有些数据被删除了(sadd myset v1, del myset)等等</p>
</li>
</ul>
<p>多条命令可以合并为一个：如sadd myset v1, sadd myset v2, sadd myset v3可以合并为sadd myset v1 v2 v3。不过为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset类型的key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。这个常量在redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD中定义，不可更改，3.0版本中值是64。</p>
<p>文件重写的触发，分为手动触发和自动触发：</p>
<p>手动触发：直接调用bgrewriteaof命令，该命令的执行与bgsave有些类似：都是fork子进程进行具体的工作，且都只有在fork时阻塞。</p>
<p>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数，以及aof_current_size和aof_base_size状态确定触发时机。</p>
<h3 id="AOF常用配置总结"><a href="#AOF常用配置总结" class="headerlink" title="AOF常用配置总结"></a>AOF常用配置总结</h3><p>appendonly no：是否开启AOF</p>
<p>appendfilename “appendonly.aof”：AOF文件名</p>
<p>dir ./：RDB文件和AOF文件所在目录</p>
<p>appendfsync everysec：fsync持久化策略</p>
<p>no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时</p>
<p>CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡</p>
<p>auto-aof-rewrite-percentage 100：文件重写触发条件之一</p>
<p>auto-aof-rewrite-min-size 64mb：文件重写触发提交之一</p>
<p>aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件</p>
<h2 id="RDB与AOF优缺点"><a href="#RDB与AOF优缺点" class="headerlink" title="RDB与AOF优缺点"></a>RDB与AOF优缺点</h2><h3 id="RDB持久化-1"><a href="#RDB持久化-1" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。</p>
<p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</p>
<h3 id="AOF持久化-1"><a href="#AOF持久化-1" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>与RDB持久化相对应，AOF的优点在于支持<strong>秒级持久化、兼容性好</strong>，缺点是<strong>文件大、恢复速度慢、对性能影响大</strong>。</p>
<h2 id="持久化策略选择"><a href="#持久化策略选择" class="headerlink" title="持久化策略选择"></a>持久化策略选择</h2><p>在介绍持久化策略之前，首先要明白无论是RDB还是AOF，持久化的开启都是要付出性能方面代价的：对于RDB持久化，一方面是bgsave在进行fork操作时Redis主进程会阻塞，另一方面，子进程向硬盘写数据也会带来IO压力；对于AOF持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题（后面会详细介绍这种阻塞），此外，AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。</p>
<p>下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。</p>
<ol>
<li><p>如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。</p>
</li>
<li><p>在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。</p>
</li>
<li><p>但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。</p>
</li>
</ol>
<p>在这种情况下，一种可行的做法是：</p>
<p><em>master：完全关闭持久化</em>（包括RDB和AOF），这样可以让master的性能达到最好</p>
<p><em>slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以）</em>，<em>并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调用bgrewriteaof。</em></p>
<p>这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：</p>
<p>master和slave进程同时停止：考虑这样一种场景，如果master和slave在同一栋大楼或同一个机房，则一次停电事故就可能导致master和slave机器同时关机，Redis进程停止；如果没有持久化，则面临的是数据的完全丢失。</p>
<p>master误重启：考虑这样一种场景，master服务因为故障宕掉了，如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将master自动重启，由于没有持久化文件，那么master重启后数据是空的，slave同步数据也变成了空的；如果master和slave都没有持久化，同样会面临数据的完全丢失。需要注意的是，即便是使用了哨兵(关于哨兵后面会有文章介绍)进行自动的主从切换，也有可能在哨兵轮询到master之前，便被自动拉起机制重启了。因此，应尽量避免“自动拉起机制”和“不做持久化”同时出现。</p>
<ol start="4">
<li>异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。例如对于单机的情形，可以定时将RDB文件或重写后的AOF文件，通过scp拷贝到远程机器，如阿里云、AWS等；对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上。一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其他条件来确定，但最好不要低于一天一次。</li>
</ol>
<h2 id="fork阻塞：CPU阻塞"><a href="#fork阻塞：CPU阻塞" class="headerlink" title="fork阻塞：CPU阻塞"></a>fork阻塞：CPU阻塞</h2><p>在Redis的实践中，众多因素限制了Redis单机的内存不能过大，例如：</p>
<ul>
<li>当面对请求的暴增，需要<em>从库扩容</em>时，Redis内存过大会导致<strong>扩容时间太长</strong>；</li>
<li>当<em>主机宕机</em>时，切换主机后需<em>要挂载从库</em>，Redis内存过大导致<strong>挂载速度过慢</strong>；</li>
<li>以及<strong>持久化过程中的fork操作</strong>，下面详细说明。</li>
</ul>
<p>父进程通过fork操作可以创建子进程；子进程创建后，父子进程共享代码段，不共享进程的数据空间，但是子进程会获得父进程的数据空间的副本。在操作系统fork的实际实现中，基本都采用了写时复制技术，即在父/子进程试图修改数据空间之前，父子进程实际上共享数据空间；但是当父/子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分(内存的一页)制作一个副本。</p>
<p>虽然fork时，子进程不会复制父进程的数据空间，但是会<strong>复制内存页表</strong>（页表相当于内存的索引、目录）；父进程的数据空间越大，内存页表越大，fork时复制耗时也会越多。</p>
<p>在Redis中，无论是<code>RDB</code>持久化的<code>bgsave</code>，还是<code>AOF</code>重写的<code>bgrewriteaof</code>，都需要fork出子进程来进行操作。如果Redis内存过大，会导致fork操作时<strong>复制内存页表耗时过多</strong>；而Redis主进程在进行fork时，是完全阻塞的，也就意味着无法响应客户端的请求，会造成请求延迟过大。</p>
<p>为了减轻fork操作带来的阻塞问题，除了控制Redis单机内存的大小以外，还可以<em>适度放宽AOF重写</em>的触发条件、选用<em>物理机</em>或<em>高效支持fork操作的虚拟化技术</em>等，例如使用Vmware或KVM虚拟机，不要使用Xen虚拟机。</p>
<h2 id="AOF追加阻塞：硬盘阻塞"><a href="#AOF追加阻塞：硬盘阻塞" class="headerlink" title="AOF追加阻塞：硬盘阻塞"></a>AOF追加阻塞：硬盘阻塞</h2><p>在AOF中，如果AOF缓冲区的文件同步策略为everysec，则：<em>在主线程中，命令写入aof_buf后调用系统write操作，write完成后主线程返回；fsync同步文件操作由专门的文件同步线程每秒调用一次。</em></p>
<p>如果硬盘负载过高，那么fsync操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快；如果此时Redis进程异常退出，丢失的数据也会越来越多，可能远超过1s。</p>
<p>为此，Redis的处理策略是这样的：主线程每次<strong>进行AOF会对比上次fsync成功的时间</strong>；如果距上次<em>不到2s，主线程直接返回</em>；如果<em>超过2s，则主线程阻塞直到fsync同步完成</em>。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，<strong>使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。</strong> </p>
<h1 id="集群作用"><a href="#集群作用" class="headerlink" title="集群作用"></a>集群作用</h1><p>集群，即Redis Cluster。</p>
<p>集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责<strong>读写请求</strong>和集群<strong>信息的维护</strong>；从节点只进行<strong>主节点数据和状态信息的复制</strong>。</p>
<p>作用可归纳为两点：数据分区和高可用</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据分区(或称数据分片)是集群最<strong>核心</strong>的功能。</p>
<p>集群将数据分散到多个节点：一方面突破了Redis<strong>单机内存大小</strong>的限制，存储容量大大增加；另一方面每个主节点都可以<strong>对外提供读服务和写服务</strong>，大大提高了集群的响应能力。</p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>集群支持<strong>主从复制</strong>和<strong>主节点的自动故障转移</strong>（与哨兵类似）：当任一节点发生故障时，集群仍然可以对外提供服务。</p>
<h1 id="集群的搭建"><a href="#集群的搭建" class="headerlink" title="集群的搭建"></a>集群的搭建</h1><p>集群的搭建可以分为四步：</p>
<ul>
<li>  （1）<strong>启动节点</strong>：将节点以集群模式启动，此时节点是独立的，并没有建立联系；</li>
<li>  （2）<strong>节点握手</strong>：让独立的节点连成一个网络；</li>
<li>  （3）<strong>分配槽</strong>：将16384个槽分配给主节点；</li>
<li>  （4）<strong>指定主从关系</strong>：为从节点指定主节点。</li>
</ul>
<p>实际上，<em>前三步</em>完成后集群便<em>可对外提供服务</em>；但<em>指定从节点</em>后，集群才能够<em>提供真正高可用</em>的服务。</p>
<h2 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h2><p>集群节点的启动仍然是使用<code>redis-server</code>命令，但需要使用<strong>集群模式启动</strong>。下面是port:7000节点的配置文件（只列出了节点正常工作关键配置，其他配置(如开启AOF)可以参照单机节点进行）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">redis-7000.conf</span></span><br><span class="line">port 7000</span><br><span class="line">cluster-enabled yes			# 启动集群模式</span><br><span class="line">cluster-config-file &quot;node-7000.conf&quot;	# 指定集群配置文件的位置</span><br><span class="line">logfile &quot;log-7000.log&quot;</span><br><span class="line">dbfilename &quot;dump-7000.rdb&quot;</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>

<p><strong>当Redis节点以集群模式启动时，会首先寻找是否有集群配置文件，如果有则使用文件中的配置启动，如果没有，则初始化配置并将配置保存到文件中。</strong>集群配置文件由Redis节点维护，不需要人工修改。</p>
<p>编辑好配置文件后，使用redis-server命令启动该节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-7000.conf</span><br></pre></td></tr></table></figure>

<p>需要特别注意，在<strong>启动节点阶段，节点是没有主从关系的，因此从节点不需要加slaveof配置</strong>。</p>
<h2 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h2><p>节点启动以后是相互独立的，并不知道其他节点存在；需要进行节点握手，将独立的节点组成一个网络。</p>
<p>节点握手使用cluster meet {ip} {port}命令实现。</p>
<h2 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h2><p>在Redis集群中，借助槽实现数据分区。</p>
<p><strong>集群有16384个槽，槽是数据管理和迁移的基本单位。当数据库中的16384个槽都分配了节点时，集群处于上线状态（ok）；如果有任意一个槽没有分配节点，则集群处于下线状态（fail）。</strong></p>
<p>分配槽使用cluster addslots命令，执行下面的命令将槽（编号0-16383）全部分配完毕：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7000 cluster addslots &#123;0..5461&#125;	</span><br><span class="line">redis-cli -p 7001 cluster addslots &#123;5462..10922&#125;	</span><br><span class="line">redis-cli -p 7002 cluster addslots &#123;10923..16383&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="指定主从关系"><a href="#指定主从关系" class="headerlink" title="指定主从关系"></a>指定主从关系</h2><p>集群中指定主从关系不再使用slaveof命令，而是使用cluster replicate命令；参数使用节点id。</p>
<p>通过cluster nodes获得几个主节点的节点id后，执行下面的命令为每个从节点指定主节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 8000 cluster replicate be816eba968bc16c884b963d768c945e86ac51ae</span><br><span class="line"><span class="meta">#</span><span class="bash"> 8000从节点端口 be816eba968bc16c884b963d768c945e86ac51ae主节点id</span></span><br></pre></td></tr></table></figure>

<h1 id="集群设计方案"><a href="#集群设计方案" class="headerlink" title="集群设计方案"></a>集群设计方案</h1><p>设计集群方案时，至少要考虑以下因素：</p>
<p>（1）<strong>高可用要求</strong>：根据故障转移的原理，至少需要3个主节点才能完成故障转移，且3个主节点不应在同一台物理机上；每个主节点至少需要1个从节点，且主从节点不应在一台物理机上；因此<strong>高可用集群至少包含6个节点</strong>。</p>
<p>（2）<strong>数据量和访问量</strong>：估算应用需要的数据量和总访问量(考虑业务发展，留有冗余)，结合每个主节点的容量和能承受的访问量(可以通过benchmark得到较准确估计)，计算需要的<strong>主节点数量</strong>。</p>
<p>（3）<strong>节点数量限制</strong>：Redis官方给出的<strong>节点数量限制为1000</strong>，主要是考虑节点间通信带来的消耗。在实际应用中应尽量避免大集群；如果节点数量不足以满足应用对Redis数据量和访问量的要求，可以考虑：(1)业务分割，大集群分为多个小集群；(2)减少不必要的数据；(3)调整数据过期策略等。</p>
<p>（4）<strong>适度冗余</strong>：Redis可以在不影响集群服务的情况下增加节点，因此节点数量适当冗余即可，不用太大。</p>
<h1 id="集群的基本原理"><a href="#集群的基本原理" class="headerlink" title="集群的基本原理"></a>集群的基本原理</h1><p>集群最核心的功能是数据分区，因此首先介绍<strong>数据的分区规则</strong>；然后介绍<strong>集群实现的细节</strong>：通信机制和数据结构；最后以cluster meet(节点握手)、cluster addslots(槽分配)为例，说明节点是如何利用上述数据结构和通信机制实现集群命令的。</p>
<h2 id="集群数据分区方案"><a href="#集群数据分区方案" class="headerlink" title="集群数据分区方案"></a>集群数据分区方案</h2><p>数据分区有顺序分区、哈希分区等，其中哈希分区由于其天然的随机性，使用广泛；<em>集群的分区方案便是哈希分区的一种。</em></p>
<p>哈希分区的基本思路是：<strong>对数据的特征值（如key）进行哈希，然后根据哈希值决定数据落在哪个节点</strong>。常见的哈希分区包括：哈希取余分区、一致性哈希分区、带虚拟节点的一致性哈希分区等。</p>
<p>衡量数据分区方法好坏的标准有很多，其中比较重要的<strong>两个因素</strong>是(1)<strong>数据分布是否均匀</strong>(2)<strong>增加或删减节点对数据分布的影响</strong>。由于哈希的随机性，哈希分区基本可以保证数据分布均匀；因此在比较哈希分区方案时，重点要看增减节点对数据分布的影响。</p>
<h3 id="哈希取余分区"><a href="#哈希取余分区" class="headerlink" title="哈希取余分区"></a>哈希取余分区</h3><p>哈希取余分区思路非常简单：计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。该方案最大的问题是，当<strong>新增或删减</strong>节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。</p>
<h3 id="一致性哈希分区"><a href="#一致性哈希分区" class="headerlink" title="一致性哈希分区"></a>一致性哈希分区</h3><p>一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，范围为0-2^32-1；对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。</p>
<p>一致性哈希分区的主要问题在于，当节点数量较少时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。</p>
<h3 id="带虚拟节点的一致性哈希"><a href="#带虚拟节点的一致性哈希" class="headerlink" title="带虚拟节点的一致性哈希"></a>带虚拟节点的一致性哈希</h3><p>该方案在一致性哈希分区的基础上，引入了虚拟节点的概念。<strong>Redis集群使用的便是该方案，其中的虚拟节点称为槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念；<strong>每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据</strong>。引入槽以后，数据的映射关系由数据hash-&gt;实际节点，变成了数据<strong>hash-&gt;槽-&gt;实际节点</strong>。</p>
<p><strong>在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小。</strong></p>
<p>在Redis集群中，槽的数量为<strong>16384</strong>。</p>
<p>下面这张图很好的总结了Redis集群将数据映射到实际节点的过程：</p>
<img src="/2021/08/03/redis%E7%AC%94%E8%AE%B0/%E5%93%88%E5%B8%8C%E6%A7%BD%E5%AF%B9%E5%BA%94%E5%AE%9E%E9%99%85%E6%95%B0%E6%8D%AE%E8%A7%86%E5%9B%BE.png" class="" title="1174710-20190802191100758-1110624103">

<p>（1）Redis对数据的特征值（一般是key）计算哈希值，使用的算法是CRC16。</p>
<p>（2）根据哈希值，计算数据属于哪个槽。</p>
<p>（3）根据槽与节点的映射关系，计算数据属于哪个节点。</p>
<h2 id="节点间通信机制"><a href="#节点间通信机制" class="headerlink" title="节点间通信机制"></a>节点间通信机制</h2><h3 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h3><p>在哨兵系统中，节点分为数据节点和哨兵节点：前者存储数据，后者实现额外的控制功能。<strong>在集群中，没有数据节点与非数据节点之分：所有的节点都存储数据，也都参与集群状态的维护</strong>。为此，集群中的每个节点，都提供了两个TCP端口：</p>
<ul>
<li>  <strong>普通端口</strong>：即我们在前面指定的端口(7000等)。普通端口主要用于为客户端提供服务（与单机节点类似）；但在节点间数据迁移时也会使用。</li>
<li>  <strong>集群端口</strong>：端口号是<strong>普通端口+10000</strong>（10000是固定值，无法改变），如7000节点的集群端口为17000。<strong>集群端口只用于节点之间的通信</strong>，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</li>
</ul>
<h3 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h3><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip协议等。重点是广播和Gossip的对比。</p>
<p>广播是指向集群内所有节点发送消息；优点是集群的<strong>收敛速度快</strong>(集群收敛是指集群内所有节点获得的集群信息是一致的)，缺点是每条消息都要发送给所有节点，<strong>CPU、带宽等消耗较大</strong>。</p>
<p>Gossip协议的特点是：在节点数量有限的网络中，每个节点都<strong>“随机”</strong>的<strong>与部分节点通信</strong>（并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip协议的优点有<strong>负载(比广播)低、去中心化、容错性高</strong>(因为通信有冗余)等；缺点主要是集群的<strong>收敛速度慢</strong>。</p>
<h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p><em>集群中的节点采用固定频率（每秒10次）的定时任务进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。</em>如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p>
<p>节点间发送的消息主要分为5种：meet消息、ping消息、pong消息、fail消息、publish消息：</p>
<ul>
<li>  <strong>MEET</strong>消息：在节点<strong>握手阶段</strong>，当节点收到客户端的<code>CLUSTER MEET</code>命令时，会向新加入的节点发送MEET消息，请求新节点加入到当前集群；新节点收到MEET消息后会回复一个PONG消息。</li>
<li>  <strong>PING</strong>消息：集群里<strong>每个节点每秒钟会选择部分节点发送PING消息，接收者收到消息后会回复一个PONG消息</strong>。PING消息的<em>内容是自身节点和部分其他节点的状态信息</em>；作用是彼此<strong>交换信息</strong>，以及<strong>检测节点是否在线</strong>。PING消息使用Gossip协议发送，接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：(1)<em>随机找5个节点，在其中选择最久没有通信的1个节点(2)扫描节点列表，选择最近一次收到PONG消息时间大于cluster_node_timeout/2的所有节点，防止这些节点长时间未更新。</em></li>
<li>  <strong>PONG</strong>消息：PONG消息封装了<strong>自身状态</strong>数据。可以分为两种：第一种是在<strong>接到MEET/PING消息后回复的PONG消息</strong>；第二种是指节点向集群<strong>广播PONG消息</strong>，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播PONG消息。</li>
<li>  <strong>FAIL</strong>消息：当一个<strong>主节点判断另一个主节点进入FAIL状态</strong>时，会向集群<em>广播这一FAIL消息</em>；接收节点会将这一FAIL消息保存起来，便于后续的判断。</li>
<li>  <strong>PUBLISH</strong>消息：节点收到<code>PUBLISH</code>命令后，<strong>会先执行</strong>该命令，<strong>然后向集群广播</strong>这一消息，<em>接收节点也会执行</em>该PUBLISH命令。</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……</p>
<p>节点为了存储集群状态而提供的数据结构中，最关键的是<code>clusterNode</code>和<code>clusterState</code>结构：前者记录了<strong>一个节点的状态</strong>，后者记录了<strong>集群作为一个整体的状态</strong>。</p>
<p><strong>clusterNode</strong></p>
<p>clusterNode结构保存了一个节点的当前状态，包括创建时间、节点id、ip和端口号等。<em>每个节点都会用一个clusterNode结构记录自己的状态，并为集群内所有其他节点都创建一个clusterNode结构来记录节点状态。</em></p>
<p>下面列举了clusterNode的部分字段，并说明了字段的含义和作用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//节点创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点id</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点的ip和端口号</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//配置纪元：故障转移时起作用，类似于哨兵的配置纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点中槽的数量</span></span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line"> </span><br><span class="line">    …………</span><br><span class="line"> </span><br><span class="line">&#125; clusterNode;</span><br></pre></td></tr></table></figure>

<p>除了上述字段，clusterNode还包含节点连接、主从复制、故障发现和转移需要的信息等。</p>
<p><strong>clusterState</strong></p>
<p>clusterState结构保存了在当前节点视角下，<strong>集群所处的状态</strong>。主要字段包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//自身节点</span></span><br><span class="line">    clusterNode *myself;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//配置纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//集群状态：在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//集群中至少包含一个槽的节点数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//哈希表，节点名称-&gt;clusterNode节点指针</span></span><br><span class="line">    dict *nodes;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL</span></span><br><span class="line">    clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line"> </span><br><span class="line">    …………</span><br><span class="line">     </span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>

<p>除此之外，clusterState还包括故障转移、槽迁移等需要的信息。</p>
<h2 id="集群命令实现"><a href="#集群命令实现" class="headerlink" title="集群命令实现"></a>集群命令实现</h2><p>以<code>cluster meet</code>(节点握手)、<code>cluster addslots</code>(槽分配)为例，说明节点是如何利用上述数据结构和通信机制实现集群命令的。</p>
<p>假设要向A节点发送<code>cluster meet</code>命令，将<em>B节点加入到A所在的集群</em>，则A节点收到命令后，执行的操作如下：</p>
<ol>
<li><p> <em>A</em>为B<em>创建一个clusterNode结构</em>，并将其<em>添加到clusterState的nodes</em>字典中</p>
</li>
<li><p> A向B发送<code>MEET</code>消息-一次握手</p>
</li>
<li><p> <em>B收到MEET</em>消息后，会为A<em>创建一个clusterNode结构</em>，并将其<em>添加到clusterState的nodes</em>字典中</p>
</li>
<li><p> B回复A一个<code>PONG</code>消息-一次握手</p>
</li>
<li><p> A收到B的PONG消息后，便知道B已经成功接收自己的MEET消息</p>
</li>
<li><p> 然后，A向B返回一个PING消息-一次握手</p>
</li>
<li><p> B收到A的PING消息后，便知道A已经成功接收自己的PONG消息，握手完成</p>
</li>
<li><p> 之后，<em>A</em>通过Gossip协议<em>将B的信息广播给集群内其他节点</em>，<em>其他节点也会与B握手</em>；一段时间后，集群收敛，B成为集群内的一个普通节点</p>
</li>
</ol>
<p>通过上述过程可以发现，集群中两个节点的握手过程与TCP类似，都是三次握手：A向B发送MEET；B向A发送PONG；A向B发送PING。保证可靠性</p>
<p><strong>cluster addslots</strong></p>
<p>集群中<em>槽的分配信息，存储在clusterNode的slots数组和clusterState的slots数组中</em>；二者的区别在于：前者存储的是<strong>该节点中分配了哪些槽</strong>，后者存储的是<strong>集群中所有槽分别分布在哪个节点</strong>。</p>
<p>cluster addslots命令接收一个槽或多个槽作为参数，例如在A节点上执行cluster addslots {0..10}命令，是将编号为0-10的槽分配给A节点，具体执行过程如下：</p>
<ol>
<li><p> <em>遍历输入槽，检查它们是否都没有分配，如果有一个槽已分配，命令执行失败；方法是检查输入槽在clusterState.slots[]中对应的值是否为NULL。</em></p>
</li>
<li><p> <em>遍历输入槽，将其分配给节点A；方法是修改clusterNode.slots[]中对应的比特为1，以及clusterState.slots[]中对应的指针指向A节点</em></p>
</li>
<li><p> A节点执行完成后，通过节点通信机制<em>通知其他节点</em>，所有节点都会知道0-10的槽分配给了A节点</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">yousec</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/08/03/redis%E7%AC%94%E8%AE%B0/">http://example.com/2021/08/03/redis%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">redis主从复制</a><a class="post-meta__tags" href="/tags/redis%E9%AB%98%E5%8F%AF%E7%94%A8/">redis高可用</a><a class="post-meta__tags" href="/tags/redis%E9%9B%86%E7%BE%A4/">redis集群</a><a class="post-meta__tags" href="/tags/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">redis数据类型</a><a class="post-meta__tags" href="/tags/redis%E7%BC%96%E7%A0%81/">redis编码</a><a class="post-meta__tags" href="/tags/redis%E6%8C%81%E4%B9%85%E5%8C%96/">redis持久化</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/10/HTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">HTTP协议笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/03/kafka%E5%85%AB%E8%82%A1%E6%96%87/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">kafka</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yousec</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">27</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">redis的主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-number">1.1.1.</span> <span class="toc-text">全量复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">增量复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">redis复制流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">读写分离以及存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E4%B8%8E%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">1.3.1.</span> <span class="toc-text">延迟与不一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">数据过期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2"><span class="toc-number">1.3.3.</span> <span class="toc-text">故障切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E8%B6%85%E6%97%B6"><span class="toc-number">1.4.</span> <span class="toc-text">复制超时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E5%88%A4%E6%96%AD%E6%84%8F%E4%B9%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">超时判断意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">判断机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">1.5.</span> <span class="toc-text">复制缓冲区溢出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E7%9A%84%E4%BA%94%E7%A7%8D%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">redis的五种对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E6%8B%AC"><span class="toc-number">2.1.1.</span> <span class="toc-text">概括</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">内部编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.3.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E6%8B%AC-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">概括</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">内部编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">2.3.</span> <span class="toc-text">哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E6%8B%AC-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">概括</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">内部编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-2"><span class="toc-number">2.3.3.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">2.4.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">内部编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-3"><span class="toc-number">2.4.3.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">2.5.</span> <span class="toc-text">有序集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E6%8B%AC-3"><span class="toc-number">2.5.1.</span> <span class="toc-text">概括</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">内部编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-4"><span class="toc-number">2.5.3.</span> <span class="toc-text">编码转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E5%86%85%E5%AD%98%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">redis内存应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%B0%E7%AE%97redis%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">估算redis内存使用量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redisObject"><span class="toc-number">3.1.1.</span> <span class="toc-text">redisObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS"><span class="toc-number">3.1.2.</span> <span class="toc-text">SDS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">3.1.3.</span> <span class="toc-text">举例说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">优化内存占用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%8E%87"><span class="toc-number">3.3.</span> <span class="toc-text">关注内存碎片率</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">redis高可用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">redis 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text">RDB持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.2.1.</span> <span class="toc-text">触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.2.2.</span> <span class="toc-text">RDB常用设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.3.</span> <span class="toc-text">AOF持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AFAOF"><span class="toc-number">5.3.1.</span> <span class="toc-text">开启AOF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.2.</span> <span class="toc-text">执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%BF%BD%E5%8A%A0"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">命令追加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%EF%BC%9A%E5%86%99%E5%85%A5write%E4%B8%8E%E5%90%8C%E6%AD%A5sync%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">文件：写入write与同步sync函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">文件重写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="toc-number">5.3.3.</span> <span class="toc-text">AOF常用配置总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB%E4%B8%8EAOF%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.4.</span> <span class="toc-text">RDB与AOF优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96-1"><span class="toc-number">5.4.1.</span> <span class="toc-text">RDB持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96-1"><span class="toc-number">5.4.2.</span> <span class="toc-text">AOF持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5%E9%80%89%E6%8B%A9"><span class="toc-number">5.5.</span> <span class="toc-text">持久化策略选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork%E9%98%BB%E5%A1%9E%EF%BC%9ACPU%E9%98%BB%E5%A1%9E"><span class="toc-number">5.6.</span> <span class="toc-text">fork阻塞：CPU阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF%E8%BF%BD%E5%8A%A0%E9%98%BB%E5%A1%9E%EF%BC%9A%E7%A1%AC%E7%9B%98%E9%98%BB%E5%A1%9E"><span class="toc-number">5.7.</span> <span class="toc-text">AOF追加阻塞：硬盘阻塞</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%BD%9C%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">集群作用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-number">6.1.</span> <span class="toc-text">数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">高可用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA"><span class="toc-number">7.</span> <span class="toc-text">集群的搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%8A%82%E7%82%B9"><span class="toc-number">7.1.</span> <span class="toc-text">启动节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%8F%A1%E6%89%8B"><span class="toc-number">7.2.</span> <span class="toc-text">节点握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%A7%BD"><span class="toc-number">7.3.</span> <span class="toc-text">分配槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%B8%BB%E4%BB%8E%E5%85%B3%E7%B3%BB"><span class="toc-number">7.4.</span> <span class="toc-text">指定主从关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">8.</span> <span class="toc-text">集群设计方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">集群的基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88"><span class="toc-number">9.1.</span> <span class="toc-text">集群数据分区方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E5%88%86%E5%8C%BA"><span class="toc-number">9.1.1.</span> <span class="toc-text">哈希取余分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA"><span class="toc-number">9.1.2.</span> <span class="toc-text">一致性哈希分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">9.1.3.</span> <span class="toc-text">带虚拟节点的一致性哈希</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">9.2.</span> <span class="toc-text">节点间通信机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%AB%AF%E5%8F%A3"><span class="toc-number">9.2.1.</span> <span class="toc-text">两个端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gossip%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.2.2.</span> <span class="toc-text">Gossip协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.2.3.</span> <span class="toc-text">消息类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.3.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.4.</span> <span class="toc-text">集群命令实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96/" title="操作系统笔记之内核初始化"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统笔记之内核初始化"/></a><div class="content"><a class="title" href="/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96/" title="操作系统笔记之内核初始化">操作系统笔记之内核初始化</a><time datetime="2021-08-22T09:24:57.000Z" title="Created 2021-08-22 17:24:57">2021-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B9%8BCPU%E7%9A%84%E8%AE%A4%E7%9F%A5/" title="操作系统笔记之CPU的认知"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统笔记之CPU的认知"/></a><div class="content"><a class="title" href="/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B9%8BCPU%E7%9A%84%E8%AE%A4%E7%9F%A5/" title="操作系统笔记之CPU的认知">操作系统笔记之CPU的认知</a><time datetime="2021-08-21T07:34:15.000Z" title="Created 2021-08-21 15:34:15">2021-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/10/HTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/" title="HTTP协议笔记"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP协议笔记"/></a><div class="content"><a class="title" href="/2021/08/10/HTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/" title="HTTP协议笔记">HTTP协议笔记</a><time datetime="2021-08-09T16:35:11.000Z" title="Created 2021-08-10 00:35:11">2021-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/03/redis%E7%AC%94%E8%AE%B0/" title="redis笔记"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis笔记"/></a><div class="content"><a class="title" href="/2021/08/03/redis%E7%AC%94%E8%AE%B0/" title="redis笔记">redis笔记</a><time datetime="2021-08-03T15:08:40.000Z" title="Created 2021-08-03 23:08:40">2021-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/03/kafka%E5%85%AB%E8%82%A1%E6%96%87/" title="kafka"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kafka"/></a><div class="content"><a class="title" href="/2021/08/03/kafka%E5%85%AB%E8%82%A1%E6%96%87/" title="kafka">kafka</a><time datetime="2021-08-03T15:04:44.000Z" title="Created 2021-08-03 23:04:44">2021-08-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By yousec</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-58o8.vercel.app/',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twikoo-58o8.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>