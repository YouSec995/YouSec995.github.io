<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>tcp_ip八股文 | YouSec</title><meta name="keywords" content="面试,HTTP,TCP/IP,UDP"><meta name="author" content="yousec"><meta name="copyright" content="yousec"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="UDPudp协议属于传输层协议。 udp报文协议   16位源端口号 16位目的端口号    16位UDP长度 16为UDP校验和   数据内容 数据内容   0                                                                        15 16">
<meta property="og:type" content="article">
<meta property="og:title" content="tcp_ip八股文">
<meta property="og:url" content="http://example.com/2021/08/03/tcp-ip%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="YouSec">
<meta property="og:description" content="UDPudp协议属于传输层协议。 udp报文协议   16位源端口号 16位目的端口号    16位UDP长度 16为UDP校验和   数据内容 数据内容   0                                                                        15 16">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-08-03T15:00:18.000Z">
<meta property="article:modified_time" content="2021-08-03T15:02:04.661Z">
<meta property="article:author" content="yousec">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="HTTP">
<meta property="article:tag" content="TCP&#x2F;IP">
<meta property="article:tag" content="UDP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/08/03/tcp-ip%E5%85%AB%E8%82%A1%E6%96%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'tcp_ip八股文',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-03 23:02:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="YouSec" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-fw fa fa-book"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YouSec</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-fw fa fa-book"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">tcp_ip八股文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-08-03T15:00:18.000Z" title="Created 2021-08-03 23:00:18">2021-08-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-08-03T15:02:04.661Z" title="Updated 2021-08-03 23:02:04">2021-08-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="tcp_ip八股文"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>udp协议属于传输层协议。</p>
<h2 id="udp报文协议"><a href="#udp报文协议" class="headerlink" title="udp报文协议"></a>udp报文协议</h2><table>
<thead>
<tr>
<th align="center">16位源端口号</th>
<th align="center">16位目的端口号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">16位UDP长度</td>
<td align="center">16为UDP校验和</td>
</tr>
<tr>
<td align="center">数据内容</td>
<td align="center">数据内容</td>
</tr>
</tbody></table>
<p>0                                                                        15 16                                                                                            31</p>
<p>源端口：0<del>65535，1</del>1024为保留端口，为标准的服务端口</p>
<p>UDP长度：header + data 总长度</p>
<p>UDP校验和：伪头部、头部、data 三部分的校验和</p>
<p>数据内容：上层应用的数据，可以没有数据</p>
<ul>
<li>若校验和失败，就会丢弃数据</li>
</ul>
<h2 id="UDP协议的特点"><a href="#UDP协议的特点" class="headerlink" title="UDP协议的特点"></a>UDP协议的特点</h2><ul>
<li><p>无链接</p>
<p>  只需知道对端的IP和PORT就可以发送数据，不需要建立链接</p>
</li>
<li><p>不可靠</p>
<p>  没有确认机制，没有重传机制。若因为网络原因没有发送到对端，UDP协议层也不会返回任何错误给应用层。</p>
</li>
<li><p>面向数据报</p>
<p>  应用层交给UDP多长的报文，UDP就会直接传送过去，不会进行拆分。接收时也是一次性接受全部传送的数据报。</p>
</li>
<li><p>UDP存在接收缓冲区，单步存在发送缓冲区</p>
<p>  UDP在发送数据时没有缓冲区，会直接将数据传递给内核，内核会直接调用网卡进行传输。因为UDP不需要保证可靠机制，所以报文丢失之后不需要再重新发送。而UDP虽然有接受缓冲区，但是不会保证收到的数据顺序，缓冲区满了之后就会将新接收的报文丢弃。</p>
</li>
<li><p>双全工通信</p>
<p>  UDP可同时接收和发送数据报文。</p>
</li>
</ul>
<p>UDP协议首部有一个16位的长度，说明UDP最长可以发送64k数据(包含首部)，超过之后就需要我们手工在应用层分包。</p>
<h2 id="常见的UDP协议"><a href="#常见的UDP协议" class="headerlink" title="常见的UDP协议"></a>常见的UDP协议</h2><ul>
<li>NFS：网络文件传输协议</li>
<li>TFTP：简单文件传输协议</li>
<li>DHCP：动态主机配置协议</li>
<li>DNS：域名解析协议</li>
<li>自定义的UDP协议等</li>
</ul>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP全称为<strong>传输控制</strong>协议，必需对数据的传输进行控制。</p>
<h2 id="tcp协议报文格式"><a href="#tcp协议报文格式" class="headerlink" title="tcp协议报文格式"></a>tcp协议报文格式</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nVPhK4MP-1622623775394)(C:\Users\10288683\AppData\Roaming\Typora\typora-user-images\tcp报文协议.png)]</p>
<ul>
<li><p>源/目的端口：标识数据从哪儿来要去哪儿</p>
</li>
<li><p>32位序号：序号保证了可靠传输。TCP将传输的每一个字节都编号了，序号是本报文段数据的第一个字节编号。例如：一个报文段序号是300，其数据部分共有100字节，则下一个报文段序号为401。</p>
</li>
<li><p>32位徐仁序列号：每一个ACK对应这个确认号，它指明下一个期待收到的字节序号。其表明之前收到的所有数据都已经正确无误。确认号只有当ACK标志为1的时候才有效。<strong>建立连接时，SYN报文的ACK标志为0</strong>。</p>
</li>
<li><p>4位首部长度(数据偏移)：表示该TCP头部有多少个32位bit，所以TCP头部大长度是<strong>15*4=60</strong>。TCP默认报文大小为20字节。</p>
</li>
<li><p>6个标志位：</p>
<ul>
<li>URG:它为了标志紧急指针是否有效。</li>
<li>ACK：标识确认号是否有效。</li>
<li>PSH:提示接收端应用程序立即将接收缓冲区的数据拿走。</li>
<li>RST：它是为了处理异常连接的， 告诉连接不一致的一方，我们的连接还没有建立好， 要求对方重新建立连接。我们把携带RST标识的称为复位报文段。</li>
<li>SYN：请求建立连接；把携带SYN标识的称为同步报文段。</li>
<li>FIN：通知对端本段要关闭链接了；把携带FIN标识的称为结束报文段。</li>
</ul>
</li>
<li><p>16位紧急指针：当有些报文想优先被处理时(原来是按序处理)，设置紧急指针指向该报文，同时将紧急指针有效位置1。</p>
</li>
<li><p>16位窗口大小：若发送方发送速度大于接收方发送速度(比如发送方发送大量数据)，这时可能会导致大量数据丢失，接收方可以发送消息给发送方让其发送慢一点，这就是<strong>流量控制</strong>。接收方将自己接受缓冲器剩余空间的大小告诉发送方叫做<strong>16位窗口大小</strong>。窗口大小最大是2^16^，也就是64k。</p>
</li>
<li><p>16位校验和：发送端填充，<code>CRC</code>校验。</p>
</li>
</ul>
<h2 id="TCP确认应答机制"><a href="#TCP确认应答机制" class="headerlink" title="TCP确认应答机制"></a>TCP确认应答机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant 主机A</span><br><span class="line">participant 主机B</span><br><span class="line">主机A-&gt;&gt;主机B:数据：1~1000</span><br><span class="line">主机B-&gt;&gt;主机A:确认应答，下一个是1001</span><br><span class="line">主机A-&gt;&gt;主机B:数据：1001~2000</span><br><span class="line">主机B-&gt;&gt;主机A:确认应答，下一个是2001</span><br></pre></td></tr></table></figure>

<p>发送端放一条数据到接收端，接收端在收到一条报文后，向发送端发送一条<code>ACK</code>确认报文，告诉发送端已经成功的接收到了消息，并且希望收到的下一个序列号是多少。这个确认号就是下一个报文的序列号。</p>
<h2 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h2><p>注：虚线标识未可达，实线表示到达。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant 主机A</span><br><span class="line">participant 主机B</span><br><span class="line"> 主机A--&gt;&gt;主机B:数据：1~1000</span><br><span class="line"> Note right of 主机A:数据1到1000未到达主机B</span><br><span class="line"> Note left of 主机A:一段特定的时间间隔过后</span><br><span class="line">  主机A-&gt;&gt;主机B:数据：1~1000</span><br><span class="line">  主机B-&gt;&gt;主机A:确认应答，下一个是1001</span><br></pre></td></tr></table></figure>

<p>在传输过程中的超时重传机制。A给B发送数据，若A在一定时间没有收到B的确认应答消息，会进行重发。其中可能存在B没有收到A的消息，这时B不会应答；也可能是B的应答A没有收到，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">A-&gt;&gt;B:数据：1~1000</span><br><span class="line">B--&gt;&gt;A:确认应答，下一个是1001</span><br><span class="line">Note right of A:未收到B发送的确认应答消息</span><br><span class="line">Note left of A:一段时间间隔之后</span><br><span class="line">A-&gt;&gt;B:数据：1~1000</span><br><span class="line">B-&gt;&gt;A:确认应答，下一个是1001</span><br></pre></td></tr></table></figure>

<p>此时主机B就会收到很多重复的包，可以利用前面的16位序列号将重复的包识别出来并丢弃，这样就做到了数据去重的效果。</p>
<p>超时时间的确认：</p>
<p>​    若超时时间间隔设置的太长，会影响整体重传的效率；若设置的时间间隔太短，就可能会频繁的发送重复的包。TCP为了保证不同的网络传输效率的高效，会动态的计算这个时间间隔。</p>
<p>​    在linux中，以500ms为一个时间单位进行控制。若超过500ms没有收到应答，则重发一次；若重发一次之后仍未等待到确认应答，则等待2*500ms进行重发，下一次重发为4*500ms。依次类推，成指数级增长。当累计到一定次数，则认为网络或者对端主机出现异常，关闭链接。</p>
<h1 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>三次握手也就是建立连接的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant Client</span><br><span class="line">participant Server</span><br><span class="line">Note over Client,Server:CLOSED</span><br><span class="line">Note over Server:LISTEN</span><br><span class="line">Client -&gt;&gt; Server:连接请求：SYN=1,seq=x</span><br><span class="line">Note over Client:SYN-SENT</span><br><span class="line">Server -&gt;&gt; Client:SYN=1,ACK=1,seq=y,ack=x+1</span><br><span class="line">Note over Server:SYN-RCVD</span><br><span class="line">Client -&gt;&gt; Server:ACK=1,seq=x+1,ack=y+1</span><br><span class="line">Note over Client,Server:ESTABLISHED</span><br><span class="line">Note left of Server:数据传输开始</span><br></pre></td></tr></table></figure>

<ol>
<li>服务器由CLOSED状态转换为LISTEN(监听)状态。</li>
<li>客户端发送连接请求报文到服务端。此时报文中的同步标志位SYN置为1，选择一个初始序列号seq=x，并将客户端置为SYN-SENT(同步已发送态)状态。注意，TCP规定SYN不能携带数据，但是会消耗一个序列号。</li>
<li>TCP服务端收到报文，如果同意连接则发送应答确认报文。其中，确认报文的SYN=1，ACK=1，确认序列号为x+1，服务端也会初始化生成一个序列号y，此时服务端进入SYN-RCVD(同步收到态)状态。这个报文同样不能携带数据，但是也会消耗一个序列号。</li>
<li>TCP客户端收到确认报文后，还需要向服务器应答一个确认报文(为了链接的可靠性)。其中，ACK=1，确认序列号ack=y+1，自己的序列号req=x+1。</li>
<li>连接建立，CS之间可以相互通信收发数据。</li>
</ol>
<h3 id="第三次握手的意义："><a href="#第三次握手的意义：" class="headerlink" title="第三次握手的意义："></a>第三次握手的意义：</h3><p>​    主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的费。 </p>
<p>​    如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant Client</span><br><span class="line">participant Server</span><br><span class="line">Note over Client,Server:ESTABLISHED</span><br><span class="line">Note left of Client:主动关闭链接</span><br><span class="line">Client -&gt;&gt; Server:连接请求：FIN=1,seq=u</span><br><span class="line">Note over Client:FIN-WAIT1</span><br><span class="line">Server -&gt;&gt; Client:ACK=1,seq=v,ack=u+1</span><br><span class="line">Note over Server:CLOSE-WAIT</span><br><span class="line">Note over Client:FIN-WAIT2</span><br><span class="line">Server -&gt;&gt; Client:数据传输</span><br><span class="line">Server -&gt;&gt; Client:FIN=1,ACK=1,seq=w,ack=u+1</span><br><span class="line">Note over Server:LAST-ACK</span><br><span class="line">Client -&gt;&gt; Server:ACK=1,seq=u+1,ack=w+1</span><br><span class="line">Note over Client:TIME-WAIT (2MSL)</span><br><span class="line">Note over Client,Server:CLOSED</span><br></pre></td></tr></table></figure>

<p>在建立连接后，两边都可以断开连接。</p>
<p>此时客户端和服务器都是处于ESTABLISHED状态，然后客户端主动断开连接，服务器被动断开连接。</p>
<ol>
<li>客服端发送释放连接报文FIN，这时客户端不再发送数据。此时FIN=1,序列号seq=u(等于前面已发送的数据的最后一个字节的序号加1)，客户端进入FIN-WAIT-1状态。TCP规定及时FIN报文不携带数据也要消耗一个序列号。</li>
<li>服务端收到FIN报文，发出确认报文ACK。其中ACK=1,确认序列号ack=u+1，并且带上自己的序列号v。此时服务端进入CLOSE-WAIT(关闭等待)状态。 此时， TCP服务器会通知上层的应用，客服端向服务器方向释放了连接，处于半关闭状态，即客户端没有数据需要发送了但服务端可以发送数据到客户端让客户端处理。</li>
<li>客服端收到服务端发送的ACK报文后，客户端进入FIN-WAIT-2状态。等待服务端发送FIN释放报文。</li>
<li>服务端将所有数据发送完之后，向客户端发送FIN释放报文。其中，FIN=1，ACK=1，此时自己的序列号seq=w，确认序列号ack=u+1。此时服务端进入了LAST-ACK(最终确认)状态，等待客户端的确认报文。</li>
<li>客户端收到服务端的FIN释放报文，必需发出确认ACK报文。其中ACK=1，确认序列号ack=w+1，自己的序列号req=u+1。此时客户端进入了TIME-WAIT(时间等待)状态，必需经过2*MSL(最长报文寿命时间段)之后才能进入CLOSED状态。</li>
</ol>
<h3 id="第四次握手为什么要等待2MSL时长"><a href="#第四次握手为什么要等待2MSL时长" class="headerlink" title="第四次握手为什么要等待2MSL时长"></a>第四次握手为什么要等待2MSL时长</h3><ul>
<li><p>ACK报文的可靠性</p>
<p>  保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
</li>
<li><p>去除无效报文</p>
<p>  防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
</li>
</ul>
<h3 id="为什么握手要三次，挥手要四次"><a href="#为什么握手要三次，挥手要四次" class="headerlink" title="为什么握手要三次，挥手要四次"></a>为什么握手要三次，挥手要四次</h3><p>​    建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 </p>
<p>​    而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<h3 id="建链之后，客户端故障了怎么处理"><a href="#建链之后，客户端故障了怎么处理" class="headerlink" title="建链之后，客户端故障了怎么处理"></a>建链之后，客户端故障了怎么处理</h3><p>​    TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<p>此种机制类似心跳检测机制。</p>
<h3 id="TIME-WAIT状态解读"><a href="#TIME-WAIT状态解读" class="headerlink" title="TIME-WAIT状态解读"></a>TIME-WAIT状态解读</h3><p>​        当我们实现一个TCP服务器时，我们把这个服务器运行起来然后再将服务器关闭掉，再次重新启动服务器会发现一个问题：就是不能马上再次绑定这个端口号和ip，需要等一会才可以重新绑定，其实等的这一会就是TIME_WAIT状态。</p>
<ul>
<li>TCP协议规定主动关闭连接的一方要处于TIME_ WAIT状态，等待两个MSL的时间后才能回到CLOSED状态。</li>
<li>当我们使用Ctrl-C终止了server，server是主动关闭连接的一方在TIME_WAIT期间仍然不能再次监听同样的server端口。</li>
<li>MSL在RFC1122中规定为两分钟(120s)，但是各操作系统的实现不同，在Centos7上默认配置的值是60s可以通过cat /proc/sys/net/ipv4/tcp_fin_timeout查看MSL的值。</li>
</ul>
<p>解决TIME_WAIT状态引起的bind失败的方法：</p>
<p>​        在server的TCP连接没有完全断开之前不允许重新绑定，也就是TIME_WAIT时间没有过，但是这样不允许立即绑定在某些情况下是不某些特定场景的：</p>
<ul>
<li>服务器需要处理非常大量的客户端的连接 (每个连接的生存时间可能很短，但是每秒都有很大数量的客户 端来请求)</li>
<li>这个时候如果由服务器端主动关闭连接(比如某些客户端不活跃，就需要被服务器端主动清理掉)，这样服务器端就会产生大量TIME_WAIT状态。</li>
<li>如果客户端的请求量很大，就可能导致TIME_WAIT的连接数很多，每个连接都会占用一个通信五元组(源ip, 源端口, 目的ip, 目的端口, 协议)。其中服务器的ip和端口和协议是固定的，如果新来的客户端连接的ip和端口号和TIME_WAIT占用的连接重复就造成等待。</li>
</ul>
<p>解决方法：使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示<strong>允许创建端口号相同但IP地址不同的多个socket描述符</strong>。</p>
<h1 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h1><p>​        <strong>确认应答策略</strong>对每一个发送的数据段都要给一个ACK确认应答，接收方收到ACK后再发送下一个数据段，但是这样做有一个比较大的缺点，就是<strong>性能较差</strong>，尤其是数据往返的时间较长的时候。</p>
<p>​        考虑一次发送多条数据，它是将多个段的等待时间重叠在一起。</p>
<p>​        窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。若需要发送12个报文段。发送前四个段的时候，不需要等待任何ACK直接发送即可。当收到第一个ACK后滑动窗口向后移动，继续发送第五个段的数据，然后依次类推。<strong>操作系统内核为了维护</strong>这个滑动窗口，需要开辟<strong>发送缓冲区</strong>来记录当前还有哪些数据没有应答。只有确认应答过的数据，才能从缓冲区删掉，窗口越大，则网络的吞吐率就越高。滑动窗口<strong>左边代表已经发送过并且确认</strong>，可以从发送缓冲区中删除了，滑动窗口<strong>里边代表发送出去但是没有确认</strong>，滑动窗口<strong>右边代表还没有发送的</strong>数据。</p>
<h2 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h2><p>若出现丢包现象该怎么处理呢？</p>
<ol>
<li><p>数据到达接收方但丢失了应答报文？</p>
<p> ​    可以根据后面的应答ACK确认。假设发送了1~1000的数据，接收方接收到了但是返回的应答报文丢失。发送方继续发送1001——2000收到确认ACK 2001，则认为1-1000发送成功并成功接收了。</p>
</li>
<li><p>数据包之间丢失报文？</p>
<p> 当某一段报文1001-2000丢失后，发送端会一直收到1001的这样的ACK确认(就像在提醒发送端我想要的报文是1001开头)，若发送端连续三次收到这样的确认ACK，就会将1001-2000报文重发。这个时候接收端收到1001报文之后就会收到当前的报文段6001(假设前面发送到6000了，被放到了内核缓冲区中)。<strong>这种机制就叫做快重传</strong>。</p>
<p> ​    快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。</p>
</li>
</ol>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>​        因为接收端的处理数据能力有限，因各种原因接收端的缓冲区被填满，如果这个时候发送端继续发送就会发生丢包现象，然后引起丢包重传等一系列连锁反应。因此要根据接收端处理数据的能力来控制发送端的发送速度。这就叫<strong>流量控制</strong>。</p>
<ol>
<li>接收端将自己可以接受的缓冲区大小放在TCP首部的窗口大小字段，通过ACK确认应答报文通知发送端。</li>
<li>窗口大小越大，说明吞吐量越大，当缓冲区快满了的时候，就会将窗口值设置为一个更小的值通知给发送端。</li>
<li>当窗口大小为0之后，发送端在接收到ACK确认报文之后就不会发送数据了。但是会定期发送一个<em>窗口探测数据端</em>(防止缓冲区满了之后无法继续通信)，使接收端把窗口大小发送给发送端。</li>
</ol>
<p>象，然后引起丢包重传等一系列连锁反应。因此要根据接收端处理数据的能力来控制发送端的发送速度。这就叫<strong>流量控制</strong>。</p>
<ol>
<li>接收端将自己可以接受的缓冲区大小放在TCP首部的窗口大小字段，通过ACK确认应答报文通知发送端。</li>
<li>窗口大小越大，说明吞吐量越大，当缓冲区快满了的时候，就会将窗口值设置为一个更小的值通知给发送端。</li>
<li>当窗口大小为0之后，发送端在接收到ACK确认报文之后就不会发送数据了。但是会定期发送一个<em>窗口探测数据端</em>(防止缓冲区满了之后无法继续通信)，使接收端把窗口大小发送给发送端。</li>
</ol>
<p>​        在TCP首部的窗口大小字段，大小为16位，数据大小为65535，但由于TCP首部还有40字节的选项中包含了一个窗口扩大因子M，所以实际实际大小是窗口字段左移M位。</p>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>​        拥塞控制是TCP通信的每一方需要执行的一系列行为。这些行为是由一些特定的算法规定，用于防止网络因为大规模的通信而瘫痪。其基本方法是可以认为网络即将进入拥塞状态或已经拥塞而出现的丢包情况出现时，减缓TCP传输数据。其难点在于怎样精准的判断何时需要减缓且如何减缓TCP传输、何时恢复原有的速度。</p>
<h2 id="TCP拥塞检测"><a href="#TCP拥塞检测" class="headerlink" title="TCP拥塞检测"></a>TCP拥塞检测</h2><p>​        典型的TCP拥塞检测通常看是否有丢包出现，丢包在TCP中被用作判断拥塞发生与否指标。当然也有其他的一些方法，如时延测量、显式拥塞通知等等。</p>
<h2 id="慢启动算法"><a href="#慢启动算法" class="headerlink" title="慢启动算法"></a>慢启动算法</h2><p>​        若网络上有很多的计算机，可能当前的网络状态就已经比较拥堵，在不清楚当前网络状态下，贸然发送大量的数据是很有可能引起雪上加霜的，造成网络更加堵塞，所以需要缓慢探测可用传输资源，防止短时间内大量数据注入导致拥塞甚至瘫痪。慢启动算法就是为了这一目的设计而出的。<strong>在数据传输之初或重传计时器检测到丢包后执行慢启动</strong>，直到有丢包时执行拥塞避免算法。</p>
<p>​    注：慢启动算法和拥塞避免算法在同一时刻只会运行其中一个，但两者可相互切换。</p>
<p>​        <code>cwnd</code>为拥塞窗口大小，在发送开始的时候定义拥塞窗口大小为1，每次收到一个ACK应答拥塞窗口加1。每次发送数据包的时候，将<em>拥塞窗口</em>和<em>接收端主机反馈的窗口大小</em>做比较，取较小的值作为实际发送的窗口。<code>cwnd</code>是随时间以指数增长的。</p>
<p>​        <code>&quot;慢启动&quot;</code>只是指初使时慢，但是增长速度非常快。为了不增长的那么快，因此不能使<code>拥塞窗口</code>单纯的加倍，此处引入一个叫做<code>慢启动的阈值</code>当拥塞窗口超过这个阈值的时候，不再按照指数方式增长， 而是按照<code>线性方式</code>增长。这个阈值是慢启动阶段至拥塞避免阶段的转折点。</p>
<ul>
<li>当<code>TCP</code>开始启动的时候，慢启动<code>阈值</code>等于窗口最大值</li>
<li>在每次<code>超时重发</code>的时候，慢启动<code>阈值</code>会变成原来的一半同时拥塞窗口置回<code>1</code></li>
</ul>
<h2 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h2><p>​        在慢启动阶段，cwnd会快速增长，帮助确定一个慢启动阈值。一旦到达这阈值，意味着可能有更多的资源可被传输。若全部占用这些资源，将会使共享路由器队列的其他链接出现严重的丢包和重传情况，从而导致整个网络的不稳定。<em>为了获取更多资源而不影响其他的连接传输，引入了拥塞避免算法</em>。一旦进入慢启动阈值，TCP就会进入拥塞避免阶段，cwnd每次增长值近似于成功传输的数据段大小。这种随时间接近线性增长。</p>
<h3 id="拥塞控制与流量控制"><a href="#拥塞控制与流量控制" class="headerlink" title="拥塞控制与流量控制"></a>拥塞控制与流量控制</h3><p>​        拥塞控制是防止过多的流量进入网络中，使网络中的路由器或链路不至于过载，是一个全局性的过程。流量是点对点的通信量的控制，是一个端到端的控制问题，主要权衡发送端发送数据的速度，以便接收端能够接收。</p>
<p>​    无论是在<code>慢启动阶段</code>还是在<code>拥塞避免阶段</code>，只要发送方判断网络出现<code>拥塞</code>（其根据就是没有收到确认，虽然没有收到<code>确认</code>可能是其他原因的分组丢失，但是因为无法判定，所以都当做<code>拥塞</code>来处理），这时就把<code>慢启动门限</code>设置为<code>出现拥塞</code>时的门限的一半。然后把<code>拥塞窗口</code>设置为1，执行<code>慢启动</code>算法。</p>
<pre><code>* 加法增大：执行`拥塞避免`算法后，拥塞窗口`线性缓慢`增大，防止网络过早出现拥塞
* 乘法减小：无论是慢启动阶段还是拥塞避免，只要出现了网络拥塞（超时），那就把慢启动门限值`ssthresh`减半
</code></pre>
<h2 id="延迟应答"><a href="#延迟应答" class="headerlink" title="延迟应答"></a>延迟应答</h2><p>​        如果接收数据的主机立刻返回ACK应答，这时候返回的窗口可能比较小。假设接收端缓冲区为1M 一次收到了500K的数据。如果立刻应答，返回的窗口就是500K。 但实际上可能处理端处理的速度很快，10ms之内就把500K数据从缓冲区消费掉了，在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些也能处理过来。如果接收端稍微等一会再应答，比如等待200ms再应答，那么这个时候返回的窗口大小就是1M。</p>
<p>​        窗口越大，网络吞吐量就越大，传输效率就越高。我们的目标是在保证网络不拥塞的情况下尽量提高传输效率。</p>
<ul>
<li><p>数量限制: 每隔<code>N个包</code>就应答一次</p>
</li>
<li><p>时间限制: 超过大<code>延迟时间</code>就应答一次</p>
<p>  捎带应答：</p>
<p>  ​    在延迟应答的基础上，存在很多情况下，客户端服务器在应用层也是”一发一收” 的。 意味着客户端给服务器说了”How are you”， 服务器也会给客户端回一个”Fine, thank you”。那么这个时候ACK就可以搭顺风车，和服务器回应的 “Fine, thank you” 一起回给客户端。</p>
</li>
</ul>
<h2 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h2><p>​    当我们创建一个TCP的socket，同时在内核中创建一个发送缓冲区和一个接收缓冲区。</p>
<ul>
<li><p>调用write时，内核将数据会先写入发送缓冲区中，如果发送的字节数太长，会被拆分成多个TCP的数据包发出，如果发送的字节数太短，就会先在缓冲区里等待， 等到缓冲区长度达到设置长度，然后等到其他合适的时机发送出去。</p>
</li>
<li><p>调用read接收数据的时候， 数据也是从网卡驱动程序到达内核的接收缓冲区。然后应用程序可以调用read从接收缓冲区拿数据。TCP的一个连接，既有发送缓冲区, 也有接收缓冲区，那么对于这一个连接，既可以读数据，也可以写数据。所以是全双工的。</p>
</li>
</ul>
<p>​        由于缓冲区的存在，TCP程序的读和写不需要一一匹配。例如: 写100个字节数据时, 可以调用一次write写100个字节, 也可以调用100次write, 每次写一个字节; 读100个字节数据时, 也完全不需要考虑写的时候是怎么写的, 既可以一次read 100个字节, 也可以一次 read一个字节, 重复100次。</p>
<h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><p>​        粘包问题中的 “包”是指的应用层的数据包。在TCP的协议头中，没有如同UDP一样的 “报文长度”这样的字段，但是有一个序号这样的字段。站在传输层的角度， TCP是一个一个报文过来的，按照序号排好序放在缓冲区中，但是站在应用层的角度，它看到的只是一串连续的字节数据。应用程序看到了这么一连串的字节数据， 就不知道<strong>从哪个部分开始到哪个部分结束是一个完整的应用层数据包</strong>，这就是粘包问题。</p>
<p>​        如何解决：</p>
<ul>
<li>对于定长的包，保证每次都按固定大小读取即可。例如一个Request结构, 是固定大小的, 那么就从缓冲区从头开始按sizeof(Request)依次读取即可。</li>
<li>对于变长的包，可以在包头的位置，约定一个包总长度的字段，从而就知道了包的结束位置。</li>
<li>对于变长的包，还可以在包和包之间使用明确的分隔符(应用层协议是程序员自己来定义的, 只要保证分隔符不和正文冲突即可)。</li>
</ul>
<p>层的角度， TCP是一个一个报文过来的，按照序号排好序放在缓冲区中，但是站在应用层的角度，它看到的只是一串连续的字节数据。应用程序看到了这么一连串的字节数据， 就不知道<strong>从哪个部分开始到哪个部分结束是一个完整的应用层数据包</strong>，这就是粘包问题。</p>
<p>​        如何解决：</p>
<ul>
<li>对于定长的包，保证每次都按固定大小读取即可。例如一个Request结构, 是固定大小的, 那么就从缓冲区从头开始按sizeof(Request)依次读取即可。</li>
<li>对于变长的包，可以在包头的位置，约定一个包总长度的字段，从而就知道了包的结束位置。</li>
<li>对于变长的包，还可以在包和包之间使用明确的分隔符(应用层协议是程序员自己来定义的, 只要保证分隔符不和正文冲突即可)。</li>
</ul>
<p>对于UDP协议，如果还没有上层交付数据， UDP的报文长度仍然在。 同时UDP是一个一个把数据交付给应用层，这样就有存在明确的数据边界，站在应用层的角度， 使用UDP的时候要么收到完整的UDP报文要么不收，不会出现”半个”的情况。</p>
<h1 id="HTTP与HTTPS区别"><a href="#HTTP与HTTPS区别" class="headerlink" title="HTTP与HTTPS区别"></a>HTTP与HTTPS区别</h1><ol>
<li> https需要到ca申请证书，申请证书需要money；</li>
<li> http是超文本传输协议，信息是明文传输，https则是使用SSL/STL加密传输协议，安全性较高；</li>
<li> http使用80端口，https使用443端口；</li>
<li> http是无状态连接，https是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<h2 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h2><img src="/2021/08/03/tcp-ip%E5%85%AB%E8%82%A1%E6%96%87/https%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" class="" title="image-20210603211824919">

<ol>
<li> 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</li>
<li> Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</li>
<li> 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li>
<li> 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li>
<li> Web服务器利用自己的私钥解密出会话密钥。</li>
<li> Web服务器利用会话密钥加密与客户端之间的通信。</li>
</ol>
<p>https缺点：</p>
<ul>
<li><p>  HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p>
</li>
<li><p>  HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p>
</li>
<li><p>  SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p>
</li>
<li><p>  SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p>
</li>
<li><p>  HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击(dos)、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p>
</li>
</ul>
<h1 id="session与cookie"><a href="#session与cookie" class="headerlink" title="session与cookie"></a>session与cookie</h1><p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式</p>
<p>session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。</p>
<p>区别：</p>
<ol>
<li> cookie数据放在客户的浏览器上，session数据放在服务器上；</li>
<li> cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；</li>
<li> session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能，考虑到服务器性能应当使用cookie；</li>
<li> 单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie；</li>
</ol>
<p><strong>建议：将登录等重要信息存放在session中，其他的一些信息若需要保留，就存放在cookie中</strong>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">yousec</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/08/03/tcp-ip%E5%85%AB%E8%82%A1%E6%96%87/">http://example.com/2021/08/03/tcp-ip%E5%85%AB%E8%82%A1%E6%96%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/HTTP/">HTTP</a><a class="post-meta__tags" href="/tags/TCP-IP/">TCP/IP</a><a class="post-meta__tags" href="/tags/UDP/">UDP</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/03/kafka%E5%85%AB%E8%82%A1%E6%96%87/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">kafka</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/25/go-GC%E5%8E%9F%E7%90%86/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">go_GC原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/08/10/HTTP协议笔记/" title="HTTP协议笔记"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">HTTP协议笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yousec</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">27</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UDP"><span class="toc-number">1.</span> <span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#udp%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.</span> <span class="toc-text">udp报文协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">UDP协议的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84UDP%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.3.</span> <span class="toc-text">常见的UDP协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP"><span class="toc-number">2.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">tcp协议报文格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">TCP确认应答机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">超时重传机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">3.</span> <span class="toc-text">三次握手与四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">3.1.</span> <span class="toc-text">三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">第三次握手的意义：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">3.2.</span> <span class="toc-text">四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%AD%89%E5%BE%852MSL%E6%97%B6%E9%95%BF"><span class="toc-number">3.2.1.</span> <span class="toc-text">第四次握手为什么要等待2MSL时长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%A1%E6%89%8B%E8%A6%81%E4%B8%89%E6%AC%A1%EF%BC%8C%E6%8C%A5%E6%89%8B%E8%A6%81%E5%9B%9B%E6%AC%A1"><span class="toc-number">3.2.2.</span> <span class="toc-text">为什么握手要三次，挥手要四次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E9%93%BE%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">3.2.3.</span> <span class="toc-text">建链之后，客户端故障了怎么处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT%E7%8A%B6%E6%80%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">3.2.4.</span> <span class="toc-text">TIME-WAIT状态解读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">滑动窗口机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0"><span class="toc-number">4.1.</span> <span class="toc-text">快重传</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">流量控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%A3%80%E6%B5%8B"><span class="toc-number">5.1.</span> <span class="toc-text">TCP拥塞检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">慢启动算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">拥塞避免算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">5.3.1.</span> <span class="toc-text">拥塞控制与流量控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%BA%94%E7%AD%94"><span class="toc-number">5.4.</span> <span class="toc-text">延迟应答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">5.5.</span> <span class="toc-text">面向字节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.6.</span> <span class="toc-text">粘包问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E4%B8%8EHTTPS%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">HTTP与HTTPS区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">HTTPS工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#session%E4%B8%8Ecookie"><span class="toc-number">7.</span> <span class="toc-text">session与cookie</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96/" title="操作系统笔记之内核初始化"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统笔记之内核初始化"/></a><div class="content"><a class="title" href="/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96/" title="操作系统笔记之内核初始化">操作系统笔记之内核初始化</a><time datetime="2021-08-22T09:24:57.000Z" title="Created 2021-08-22 17:24:57">2021-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B9%8BCPU%E7%9A%84%E8%AE%A4%E7%9F%A5/" title="操作系统笔记之CPU的认知"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统笔记之CPU的认知"/></a><div class="content"><a class="title" href="/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B9%8BCPU%E7%9A%84%E8%AE%A4%E7%9F%A5/" title="操作系统笔记之CPU的认知">操作系统笔记之CPU的认知</a><time datetime="2021-08-21T07:34:15.000Z" title="Created 2021-08-21 15:34:15">2021-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/10/HTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/" title="HTTP协议笔记"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP协议笔记"/></a><div class="content"><a class="title" href="/2021/08/10/HTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/" title="HTTP协议笔记">HTTP协议笔记</a><time datetime="2021-08-09T16:35:11.000Z" title="Created 2021-08-10 00:35:11">2021-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/03/redis%E7%AC%94%E8%AE%B0/" title="redis笔记"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis笔记"/></a><div class="content"><a class="title" href="/2021/08/03/redis%E7%AC%94%E8%AE%B0/" title="redis笔记">redis笔记</a><time datetime="2021-08-03T15:08:40.000Z" title="Created 2021-08-03 23:08:40">2021-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/03/kafka%E5%85%AB%E8%82%A1%E6%96%87/" title="kafka"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kafka"/></a><div class="content"><a class="title" href="/2021/08/03/kafka%E5%85%AB%E8%82%A1%E6%96%87/" title="kafka">kafka</a><time datetime="2021-08-03T15:04:44.000Z" title="Created 2021-08-03 23:04:44">2021-08-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By yousec</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-58o8.vercel.app/',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twikoo-58o8.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>